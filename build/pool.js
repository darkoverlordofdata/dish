/** generated by dish 0.0.1 */
import Ffi from 'ffi'
import {buffer} from 'ffi'
import Stdlib from 'stdlib'
export const pool = (function(stdlib, foreign, heap) {
"use asm";
var HEAPI32 = new stdlib.Int32Array(heap);
var malloc = foreign.malloc;
var free = foreign.free;
var Entity_Entity = foreign.Entity_Entity;
var Entity_ctor = foreign.Entity_ctor;
var Entity_initialize = foreign.Entity_initialize;
var Entity_onComponentAdded = foreign.Entity_onComponentAdded;
var Entity_addComponent = foreign.Entity_addComponent;
var Entity_removeComponent = foreign.Entity_removeComponent;
var Entity_replaceComponent = foreign.Entity_replaceComponent;
var Entity_updateComponent = foreign.Entity_updateComponent;
var Entity__replaceComponent = foreign.Entity__replaceComponent;
var Entity_hasComponent = foreign.Entity_hasComponent;
var Position_Position = foreign.Position_Position;
var Position_ctor = foreign.Position_ctor;
var Position_getX = foreign.Position_getX;
var Position_setX = foreign.Position_setX;
var Position_getY = foreign.Position_getY;
var Position_setY = foreign.Position_setY;
var EntityIsNotEnabledException = foreign.EntityIsNotEnabledException;
var EntityAlreadyHasComponentException = foreign.EntityAlreadyHasComponentException;
var POOL_SIZE = 4096;
var init = 1;
var pool = 0;
var totalComponents = 0;
var count = 0;
var index = 0;
var uniqueId = 0;
function initialize(count) {
    count = count | 0;
    if (init) {
        totalComponents = count | 0;
        uniqueId = 0 | 0;
        pool = malloc(POOL_SIZE << 2) | 0;
        init = 0 | 0;
    }
}
function createPos(x, y) {
    x = +x;
    y = +y;
    return Position_ctor(+x, +y) | 0;
}
function getTotalComponents() {
    return totalComponents | 0;
}
function getCount() {
    return count | 0;
}
function createEntity() {
}
function destroyEntity(entity) {
    entity = entity | 0;
}
function destroyAllEntities() {
}
function hasEntity(entity) {
    entity = entity | 0;
}
function getEntities(matching) {
    matching = matching | 0;
}
function getGroup(matching) {
    matching = matching | 0;
}
function updateGroupsComponentAddedOrRemoved(entity, index, component) {
    entity = entity | 0;
    index = index | 0;
    component = component | 0;
}
function updateGroupsComponentReplaced(entity, index, prevcomponent, newcomponent) {
    entity = entity | 0;
    index = index | 0;
    prevcomponent = prevcomponent | 0;
    newcomponent = newcomponent | 0;
}
function onEntityReleased(entity) {
    entity = entity | 0;
}
function addComponent(entity, index, component) {
    entity = entity | 0;
    index = index | 0;
    component = component | 0;
}
function removeComponent(entity, index) {
    entity = entity | 0;
    index = index | 0;
}
function replaceComponent(entity, index, component) {
    entity = entity | 0;
    index = index | 0;
    component = component | 0;
}
function getComponent(entity, index) {
    entity = entity | 0;
    index = index | 0;
}
function hasComponent(entity, index) {
    entity = entity | 0;
    index = index | 0;
}    
return { 
    initialize:initialize,
    createPos:createPos,
    getTotalComponents:getTotalComponents,
    getCount:getCount,
    createEntity:createEntity,
    destroyEntity:destroyEntity,
    destroyAllEntities:destroyAllEntities,
    hasEntity:hasEntity,
    getEntities:getEntities,
    getGroup:getGroup,
    updateGroupsComponentAddedOrRemoved:updateGroupsComponentAddedOrRemoved,
    updateGroupsComponentReplaced:updateGroupsComponentReplaced,
    onEntityReleased:onEntityReleased,
    addComponent:addComponent,
    removeComponent:removeComponent,
    replaceComponent:replaceComponent,
    getComponent:getComponent,
    hasComponent:hasComponent, 
};
}(Stdlib, Ffi, buffer))
for (let k in pool) { 
    Ffi['pool_'+k] = pool[k] 
}
