// Generated by CoffeeScript 1.10.0

/*
## Foreign function interface
 */
var Ffi, HEAP, HEAP_SIZE, allocator;

HEAP_SIZE = 0x40000;

Ffi = (function() {
  function Ffi() {}

    Ffi.EntityIsNotEnabledException = function() {
        throw new Error('EntityIsNotEnabledException');
    };
    
    Ffi.EntityAlreadyHasComponentException =  function(index) {
        throw new Error("EntityAlreadyHasComponentException - " + index);
    }

  Ffi.now = function() {
    return performance.now();
  };


  /*
   * malloc
   *
   * @param nBytes number of bytes required
   * @returns starting offset in the heap
   */

  Ffi.malloc = function(nBytes) {
    var offset;
    if (typeof malloc !== "undefined" && malloc !== null) {
      return allocator.alloc(nBytes);
    } else {

      /*
      * Fallback:
      * this is a naive implementation of malloc. 
      * memory is only allocated, never freed.
       */
      offset = HEAP[0];
      HEAP[0] = offset + nBytes;
      return offset;
    }
  };

  Ffi.free = function(addr) {
    if (typeof malloc !== "undefined" && malloc !== null) {
      return allocator.free(addr);
    }
  };

  return Ffi;

})();

var buffer = new ArrayBuffer(HEAP_SIZE);

var bufferMax = HEAP_SIZE;

if (typeof malloc !== "undefined" && malloc !== null) {
  allocator = new malloc.Allocator(buffer);
} else {
  HEAP = new Int32Array(buffer);
  HEAP[0] = 16;
}
// Generated by CoffeeScript 1.10.0

/*
## Stdlib
 */
var Stdlib;

Stdlib = (function() {
  function Stdlib() {}

  Stdlib.Math = Math;

  Stdlib.Int8Array = Int8Array;

  Stdlib.Int16Array = Int16Array;

  Stdlib.Int32Array = Int32Array;

  Stdlib.Uint8Array = Uint8Array;

  Stdlib.Uint16Array = Uint16Array;

  Stdlib.Uint32Array = Uint32Array;

  Stdlib.Float32Array = Float32Array;

  Stdlib.Float64Array = Float64Array;

  Stdlib.NaN = NaN;

  Stdlib.Infinity = Infinity;

  return Stdlib;

})();


/** generated by dish 0.0.1 */
const entity = Ffi["entity"] = (function(stdlib, foreign, heap) {
"use asm";
var HEAPI8 = new stdlib.Int8Array(heap);
var HEAPU8 = new stdlib.Uint8Array(heap);
var HEAPI16 = new stdlib.Int16Array(heap);
var HEAPU16 = new stdlib.Uint16Array(heap);
var HEAPI32 = new stdlib.Int32Array(heap);
var HEAPU32 = new stdlib.Uint32Array(heap);
var HEAPF32 = new stdlib.Float32Array(heap);
var HEAPF64 = new stdlib.Float64Array(heap);
function getId(entity) {
    entity = entity | 0;
    var __01__ = 0, __02__ = 0;
    var id = 0;
    __01__ = entity + 0 | 0;
    __02__ = __01__ << 2;
    id = HEAPI32[__02__ >> 2] | 0;
    return id | 0;
}
function setId(entity, id) {
    entity = entity | 0;
    id = id | 0;
    var __01__ = 0, __02__ = 0;
    __01__ = entity + 0 | 0;
    __02__ = __01__ << 2;
    HEAPI32[__02__ >> 2] = id | 0;
}
function getEnabled(entity) {
    entity = entity | 0;
    var __01__ = 0, __02__ = 0;
    var enabled = 0;
    __01__ = entity + 1 | 0;
    __02__ = __01__ << 2;
    enabled = HEAPI32[__02__ >> 2] | 0;
    return enabled | 0;
}
function setEnabled(entity, enabled) {
    entity = entity | 0;
    enabled = enabled | 0;
    var __01__ = 0, __02__ = 0;
    __01__ = entity + 1 | 0;
    __02__ = __01__ << 2;
    HEAPI32[__02__ >> 2] = enabled | 0;
}
function getComponent(entity, index) {
    entity = entity | 0;
    index = index | 0;
    var __01__ = 0, __02__ = 0, __03__ = 0;
    var component = 0;
    __01__ = 2 + index | 0;
    __02__ = entity + __01__ | 0;
    __03__ = __02__ << 2;
    component = HEAPI32[__03__ >> 2] | 0;
    return component | 0;
}
function setComponent(entity, index, value) {
    entity = entity | 0;
    index = index | 0;
    value = value | 0;
    var __01__ = 0, __02__ = 0, __03__ = 0;
    __01__ = 2 + index | 0;
    __02__ = entity + __01__ | 0;
    __03__ = __02__ << 2;
    HEAPI32[__03__ >> 2] = value | 0;
}    
return { 
    getId:getId,
    setId:setId,
    getEnabled:getEnabled,
    setEnabled:setEnabled,
    getComponent:getComponent,
    setComponent:setComponent, 
};
}(Stdlib, Ffi, buffer))

const pool = Ffi["pool"] = (function(stdlib, foreign, heap) {
"use asm";
var HEAPI8 = new stdlib.Int8Array(heap);
var HEAPU8 = new stdlib.Uint8Array(heap);
var HEAPI16 = new stdlib.Int16Array(heap);
var HEAPU16 = new stdlib.Uint16Array(heap);
var HEAPI32 = new stdlib.Int32Array(heap);
var HEAPU32 = new stdlib.Uint32Array(heap);
var HEAPF32 = new stdlib.Float32Array(heap);
var HEAPF64 = new stdlib.Float64Array(heap);
var malloc = foreign.malloc;
var EntityIsNotEnabledException = foreign.EntityIsNotEnabledException;
var EntityAlreadyHasComponentException = foreign.EntityAlreadyHasComponentException;
// console.log(foreign.entity.setId)
// console.log(JSON.stringify(foreign.entity.setId))
var getId = foreign.entity.getId;
var setId = foreign.entity.setId;
var getEnabled = foreign.entity.getEnabled;
var setEnabled = foreign.entity.setEnabled;
var getComponent = foreign.entity.getComponent;
var setComponent = foreign.entity.setComponent;
var POOL_SIZE = 4096;
var init = 1;
var pool = 0;
var totalComponents = 0;
var count = 0;
var index = 0;
var entitySize = 0;
var uniqueId = 0;
function test(ptr, i) {
    ptr = ptr | 0;
    i = i | 0;
    var __01__ = 0, __02__ = 0;
    var x = 0.0;
    var value = 0;
    var k = 0;
    var result = 0;
    value = ptr;
    __01__ = value + i | 0;
    __02__ = __01__ << 2;
    result = HEAPI32[__02__ >> 2] | 0;
    return result | 0;
}
function initialize(count) {
    count = count | 0;
    var __01__ = 0, __02__ = 0;
    if (init) {
        totalComponents = count;
        __01__ = COMPONENTS * 4 | 0;
        __02__ = count * 4 | 0;
        entitySize = __02__ + __01__ | 0;
        uniqueId = 0;
        pool = (malloc(POOL_SIZE << 2) | 0) >> 2;
        init = false;
    }
}
function getTotalComponents() {
    var __00__ = 0;
    return totalComponents | 0;
}
function getCount() {
    var __00__ = 0;
    return count | 0;
}
function createEntity() {
    var __00__ = 0;
    var entity = 0;
    var i = 0;
    entity = (malloc(entitySize << 2) | 0) >> 2;
    uniqueId = uniqueId + 1 | 0;
    setId(entity, uniqueId);
    setEnabled(entity, true);
    for (i = 0; (i | 0) < totalComponents; i = i + 1 | 0) {
        setComponent(entity, i, 0);
    }
    return entity | 0;
}
function destroyEntity(entity) {
    entity = entity | 0;
    var __00__ = 0;
    free(entity);
}
function destroyAllEntities() {
    var __00__ = 0;
}
function hasEntity(entity) {
    entity = entity | 0;
    var __00__ = 0;
}
function getEntities(matching) {
    matching = matching | 0;
    var __00__ = 0;
}
function getGroup(matching) {
    matching = matching | 0;
    var __00__ = 0;
}
function updateGroupsComponentAddedOrRemoved(entity, index, component) {
    entity = entity | 0;
    index = index | 0;
    component = component | 0;
    var __00__ = 0;
}
function updateGroupsComponentReplaced(entity, index, prevcomponent, newcomponent) {
    entity = entity | 0;
    index = index | 0;
    prevcomponent = prevcomponent | 0;
    newcomponent = newcomponent | 0;
    var __00__ = 0;
}
function onEntityReleased(entity) {
    entity = entity | 0;
    var __00__ = 0;
}
function addComponent(entity, index, component) {
    entity = entity | 0;
    index = index | 0;
    component = component | 0;
    var __00__ = 0;
    setComponent(entity, index, component);
    onComponentAdded(entity, index, component);
}
function removeComponent(entity, index) {
    entity = entity | 0;
    index = index | 0;
    var __00__ = 0;
}
function replaceComponent(entity, index, component) {
    entity = entity | 0;
    index = index | 0;
    component = component | 0;
    var __00__ = 0;
}
function hasComponent(entity, index) {
    entity = entity | 0;
    index = index | 0;
    var __00__ = 0;
}    
return { 
    test:test,
    initialize:initialize,
    getTotalComponents:getTotalComponents,
    getCount:getCount,
    createEntity:createEntity,
    destroyEntity:destroyEntity,
    destroyAllEntities:destroyAllEntities,
    hasEntity:hasEntity,
    getEntities:getEntities,
    getGroup:getGroup,
    updateGroupsComponentAddedOrRemoved:updateGroupsComponentAddedOrRemoved,
    updateGroupsComponentReplaced:updateGroupsComponentReplaced,
    onEntityReleased:onEntityReleased,
    addComponent:addComponent,
    removeComponent:removeComponent,
    replaceComponent:replaceComponent,
    hasComponent:hasComponent, 
};
}(Stdlib, Ffi, buffer))

describe('Smoke Tests', function() {
    it('Pool', function() {
      return expect(pool).to.not.equal(null);
    });
    it('Entity', function() {
      return expect(entity).to.not.equal(null);
    });
    return it('CreateEntity', function() {
      var entity = pool.createEntity();
      return expect(pool.test(entity, 0)).to.equal(1);
    });
  });