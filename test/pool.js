/** generated by dish 0.0.1 */
import Ffi from 'ffi'
import {buffer} from 'ffi'
import Stdlib from 'stdlib'
export const pool = (function(stdlib, foreign, heap) {
"use asm";
var HEAPI8 = new stdlib.Int8Array(heap);
var HEAPU8 = new stdlib.Uint8Array(heap);
var HEAPI16 = new stdlib.Int16Array(heap);
var HEAPU16 = new stdlib.Uint16Array(heap);
var HEAPI32 = new stdlib.Int32Array(heap);
var HEAPU32 = new stdlib.Uint32Array(heap);
var HEAPF32 = new stdlib.Float32Array(heap);
var HEAPF64 = new stdlib.Float64Array(heap);
var malloc = foreign.malloc;
var free = foreign.free;
var Entity_ctor = foreign.Entity_ctor;
var Entity_getId = foreign.Entity_getId;
var Entity_setId = foreign.Entity_setId;
var Entity_getEnabled = foreign.Entity_getEnabled;
var Entity_setEnabled = foreign.Entity_setEnabled;
var Entity_getComponent = foreign.Entity_getComponent;
var Entity_setComponent = foreign.Entity_setComponent;
var EntityIsNotEnabledException = foreign.EntityIsNotEnabledException;
var EntityAlreadyHasComponentException = foreign.EntityAlreadyHasComponentException;
var POOL_SIZE = 4096;
var init = 1;
var pool = 0;
var totalComponents = 0;
var count = 0;
var index = 0;
var uniqueId = 0;
function test(ptr, i) {
    ptr = ptr | 0;
    i = i | 0;
    var __01__ = 0, __02__ = 0;
    var x = 0.0;
    var value = 0;
    var k = 0;
    var result = 0;
    value = ptr;
    __01__ = value + i | 0;
    __02__ = __01__ << 2;
    result = HEAPI32[__02__ >> 2] | 0;
    return result | 0;
}
function initialize(count) {
    count = count | 0;
    if (init) {
        totalComponents = count;
        uniqueId = 0;
        pool = (malloc(POOL_SIZE << 2) | 0) >> 2;
        init = 0;
    }
}
function getTotalComponents() {
    return totalComponents | 0;
}
function getCount() {
    return count | 0;
}
function createEntity() {
    var ent = 0;
    var i = 0;
    uniqueId = uniqueId + 1 | 0;
    ent = Entity_ctor(totalComponents | 0) | 0;
    Entity_setId(ent | 0, uniqueId | 0);
    Entity_setEnabled(ent | 0, 1 | 0);
    for (i = 0; (i | 0) < (totalComponents | 0); i = i + 1 | 0) {
        Entity_setComponent(ent | 0, i | 0, 0 | 0);
    }
    return ent | 0;
}
function destroyEntity(entity) {
    entity = entity | 0;
    free(entity | 0);
}
function destroyAllEntities() {
}
function hasEntity(entity) {
    entity = entity | 0;
}
function getEntities(matching) {
    matching = matching | 0;
}
function getGroup(matching) {
    matching = matching | 0;
}
function updateGroupsComponentAddedOrRemoved(entity, index, component) {
    entity = entity | 0;
    index = index | 0;
    component = component | 0;
}
function updateGroupsComponentReplaced(entity, index, prevcomponent, newcomponent) {
    entity = entity | 0;
    index = index | 0;
    prevcomponent = prevcomponent | 0;
    newcomponent = newcomponent | 0;
}
function onEntityReleased(entity) {
    entity = entity | 0;
}
function addComponent(entity, index, component) {
    entity = entity | 0;
    index = index | 0;
    component = component | 0;
    var enabled = 0;
    var comp = 0;
    enabled = Entity_getEnabled(entity | 0) | 0;
    if (!enabled) {
        EntityIsNotEnabledException();
    }
    comp = Entity_hasComponent(index)|0;
    if (comp) {
        EntityAlreadyHasComponentException(index | 0);
    }
    Entity_setComponent(entity | 0, index | 0, component | 0);
}
function removeComponent(entity, index) {
    entity = entity | 0;
    index = index | 0;
}
function replaceComponent(entity, index, component) {
    entity = entity | 0;
    index = index | 0;
    component = component | 0;
}
function hasComponent(entity, index) {
    entity = entity | 0;
    index = index | 0;
}    
return { 
    test:test,
    initialize:initialize,
    getTotalComponents:getTotalComponents,
    getCount:getCount,
    createEntity:createEntity,
    destroyEntity:destroyEntity,
    destroyAllEntities:destroyAllEntities,
    hasEntity:hasEntity,
    getEntities:getEntities,
    getGroup:getGroup,
    updateGroupsComponentAddedOrRemoved:updateGroupsComponentAddedOrRemoved,
    updateGroupsComponentReplaced:updateGroupsComponentReplaced,
    onEntityReleased:onEntityReleased,
    addComponent:addComponent,
    removeComponent:removeComponent,
    replaceComponent:replaceComponent,
    hasComponent:hasComponent, 
};
}(Stdlib, Ffi, buffer))
for (let k in pool) { 
    Ffi['pool_'+k] = pool[k] 
}
