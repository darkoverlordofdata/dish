/** generated by dish 0.0.1 */
import Ffi from 'ffi'
import {buffer} from 'ffi'
import Stdlib from 'stdlib'
export const pool = (function(stdlib, foreign, heap) {
"use asm";
var HEAPI32 = new stdlib.Int32Array(heap);
var malloc = foreign.malloc;
var free = foreign.free;
var Entity_ctor = foreign.Entity_ctor;
var Entity_Entity = foreign.Entity_Entity;
var Entity_getId = foreign.Entity_getId;
var Entity_setId = foreign.Entity_setId;
var Entity_getEnabled = foreign.Entity_getEnabled;
var Entity_setEnabled = foreign.Entity_setEnabled;
var Entity_getComponent = foreign.Entity_getComponent;
var Entity_setComponent = foreign.Entity_setComponent;
var EntityIsNotEnabledException = foreign.EntityIsNotEnabledException;
var EntityAlreadyHasComponentException = foreign.EntityAlreadyHasComponentException;
var POOL_SIZE = 4096;
var init = 1;
var pool = 0;
var totalComponents = 0;
var count = 0;
var index = 0;
var uniqueId = 0;
function initialize(count) {
    count = count | 0;
    if (init) {
        totalComponents = count;
        uniqueId = 0;
        pool = (malloc(POOL_SIZE << 2) | 0) >> 2;
        init = 0;
    }
}
function getTotalComponents() {
    return totalComponents | 0;
}
function getCount() {
    return count | 0;
}
function createEntity() {
    var ent = 0;
    var i = 0;
    uniqueId = uniqueId + 1 | 0;
    ent = Entity_ctor(totalComponents | 0) | 0;
    Entity_setId(ent | 0, uniqueId | 0);
    Entity_setEnabled(ent | 0, 1 | 0);
    for (i = 0; (i | 0) < (totalComponents | 0); i = i + 1 | 0) {
        Entity_setComponent(ent | 0, i | 0, 0 | 0);
    }
    return ent | 0;
}
function destroyEntity(entity) {
    entity = entity | 0;
    free(entity | 0);
}
function destroyAllEntities() {
}
function hasEntity(entity) {
    entity = entity | 0;
}
function getEntities(matching) {
    matching = matching | 0;
}
function getGroup(matching) {
    matching = matching | 0;
}
function updateGroupsComponentAddedOrRemoved(entity, index, component) {
    entity = entity | 0;
    index = index | 0;
    component = component | 0;
}
function updateGroupsComponentReplaced(entity, index, prevcomponent, newcomponent) {
    entity = entity | 0;
    index = index | 0;
    prevcomponent = prevcomponent | 0;
    newcomponent = newcomponent | 0;
}
function onEntityReleased(entity) {
    entity = entity | 0;
}
function addComponent(entity, index, component) {
    entity = entity | 0;
    index = index | 0;
    component = component | 0;
    var enabled = 0;
    var comp = 0;
    enabled = Entity_getEnabled(entity | 0) | 0;
    if (!enabled) {
        EntityIsNotEnabledException();
    }
    comp = Entity_hasComponent(entity | 0, index) | 0;
    if (comp) {
        EntityAlreadyHasComponentException(index | 0);
    }
    Entity_setComponent(entity | 0, index | 0, component | 0);
}
function removeComponent(entity, index) {
    entity = entity | 0;
    index = index | 0;
}
function replaceComponent(entity, index, component) {
    entity = entity | 0;
    index = index | 0;
    component = component | 0;
}
function hasComponent(entity, index) {
    entity = entity | 0;
    index = index | 0;
}    
return { 
    initialize:initialize,
    getTotalComponents:getTotalComponents,
    getCount:getCount,
    createEntity:createEntity,
    destroyEntity:destroyEntity,
    destroyAllEntities:destroyAllEntities,
    hasEntity:hasEntity,
    getEntities:getEntities,
    getGroup:getGroup,
    updateGroupsComponentAddedOrRemoved:updateGroupsComponentAddedOrRemoved,
    updateGroupsComponentReplaced:updateGroupsComponentReplaced,
    onEntityReleased:onEntityReleased,
    addComponent:addComponent,
    removeComponent:removeComponent,
    replaceComponent:replaceComponent,
    hasComponent:hasComponent, 
};
}(Stdlib, Ffi, buffer))
for (let k in pool) { 
    Ffi['pool_'+k] = pool[k] 
}
